<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>다리 건너기 퍼즐 (쾨니히스베르크 포함)</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      margin: 20px;
    }
    #game-container {
      display: inline-block;
      position: relative;
    }
    #canvas {
      border: 1px solid #333;
      background: #eef;
      cursor: pointer;
    }
    #info {
      margin-top: 10px;
      max-width: 600px;
      text-align: left;
      font-size: 14px;
    }
    .btn-group {
      margin-top: 10px;
    }
    button {
      margin: 0 4px;
      padding: 6px 10px;
      cursor: pointer;
    }
    /* 포기 확인용 오버레이 */
    #overlay,
    #result-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 600px;
      height: 400px;
      background: rgba(0, 0, 0, 0.6);
      display: none;
      align-items: center;
      justify-content: center;
      color: #fff;
      z-index: 10;
    }
    .overlay-box {
      background: #ffffff;
      color: #000;
      padding: 16px 20px;
      border-radius: 8px;
      max-width: 520px;
      text-align: left;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    }
    .overlay-box h2 {
      margin-top: 0;
    }
    .overlay-buttons {
      margin-top: 10px;
      text-align: right;
    }
    .overlay-buttons button {
      margin-left: 6px;
    }
  </style>
</head>
<body>
  <h1>다리 건너기 퍼즐</h1>
  <div id="game-container">
    <canvas id="canvas" width="600" height="400"></canvas>

    <!-- 포기 확인 오버레이 -->
    <div id="overlay">
      <div class="overlay-box">
        <h2>포기하시겠습니까?</h2>
        <p>
          이 스테이지는 아무리 시도해도 모든 다리를 한 번씩만 지나가는 한붓그리기가
          되지 않는 것처럼 느껴지나요?<br>
          그래도 한 번만 더 도전해 볼 수도 있고, 지금 포기하고 해설을 볼 수도 있어요.
        </p>
        <div class="overlay-buttons">
          <button id="giveup-cancel">아니요, 다시 도전할래요</button>
          <button id="giveup-confirm">네, 포기하고 해설 볼래요</button>
        </div>
      </div>
    </div>

    <!-- 결과/해설 오버레이 (스테이지 5 전용) -->
    <div id="result-overlay">
      <div class="overlay-box">
        <h2>쾨니히스베르크의 다리 - 왜 못 깰까?</h2>
        <p>
          이 그래프는 역사적으로 유명한 <strong>쾨니히스베르크의 다리 문제</strong>를
          단순화해서 만든 것입니다.<br><br>
          규칙은 간단했죠:
        </p>
        <ul>
          <li>모든 다리를 <strong>딱 한 번씩만</strong> 지나간다.</li>
          <li>어디서 시작해서 어디서 끝나는지는 상관 없다. (한붓그리기)</li>
        </ul>
        <p>
          그런데 어떤 다리 배치는 이렇게 한붓그리기가 가능하고, 어떤 배치는 절대
          불가능합니다.<br>
          그걸 판단해주는 개념이 바로 <strong>오일러 경로 / 오일러 회로</strong>예요.
        </p>
        <p>
          각 땅(섬)을 <strong>점(정점)</strong>으로, 다리를 <strong>선(간선)</strong>으로
          바꾸어 생각해보면, 각 점에서 몇 개의 선이 나가는지(차수)를 셉니다.
        </p>
        <ul>
          <li>모든 점의 차수가 짝수이면 → <strong>오일러 회로</strong> (시작점으로 돌아오는 한붓그리기 가능)</li>
          <li>차수가 홀수인 점이 정확히 2개이면 → <strong>오일러 경로</strong> (시작점과 끝점이 다른 한붓그리기 가능)</li>
          <li>그 외(홀수 차수 점이 0개도 2개도 아니면) → <strong>한붓그리기 자체가 불가능</strong></li>
        </ul>
        <p>
          쾨니히스베르크의 다리 그래프는 <strong>홀수 차수 정점이 4개</strong>이기 때문에
          위 조건에 걸리지 않습니다.<br>
          그래서 <strong>수학적으로 절대 한붓그리기가 불가능한 그래프</strong>예요.
        </p>
        <p style="margin-top:8px;">
          즉, 당신이 이 스테이지를 못 깬 게 아니라,<br>
          <strong>애초에 전 세계 누구도 절대 깰 수 없는 스테이지</strong>를 플레이한 겁니다 😊
        </p>
        <div class="overlay-buttons">
          <button id="result-close">처음 스테이지로 돌아가기</button>
        </div>
      </div>
    </div>

    <div id="info"></div>
    <div class="btn-group">
      <button id="prev">이전 스테이지</button>
      <button id="reset">현재 스테이지 리셋</button>
      <button id="next" style="display:none;">다음 스테이지</button>
    </div>
  </div>

  <script>
    // ===== 스테이지 정의 =====
    // nodes: {id, x, y}
    // edges: {id, a, b, offsetIndex}
    // 한붓그리기 규칙: "모든 다리를 정확히 한 번씩만 지나면 클리어"
    const levels = [
      {
        id: 1,
        title: "Stage 1 - 기본 연습",
        description: "노란 섬에서 시작해서 모든 다리를 한 번씩만 지나 보세요.",
        nodes: [
          { id: 0, x: 180, y: 120 },
          { id: 1, x: 420, y: 120 },
          { id: 2, x: 420, y: 280 },
          { id: 3, x: 180, y: 280 }
        ],
        edges: [
          // 사각형 + 대각선 하나: 한붓그리기 가능(두 개의 홀수 정점)
          { id: 0, a: 0, b: 1 },
          { id: 1, a: 1, b: 2 },
          { id: 2, a: 2, b: 3 },
          { id: 3, a: 3, b: 0 },
          { id: 4, a: 0, b: 2 }
        ],
        startNode: 0
      },
      {
        id: 2,
        title: "Stage 2 - 별 모양 그래프",
        description: "중앙 섬과 주변 섬들을 연결한 그래프입니다. 모든 다리를 한 번씩만 지나 보세요.",
        nodes: [
          { id: 0, x: 300, y: 200 }, // 중앙
          { id: 1, x: 140, y: 120 },
          { id: 2, x: 460, y: 120 },
          { id: 3, x: 460, y: 280 },
          { id: 4, x: 140, y: 280 }
        ],
        edges: [
          // 중앙-모서리 4개
          { id: 0, a: 0, b: 1 },
          { id: 1, a: 0, b: 2 },
          { id: 2, a: 0, b: 3 },
          { id: 3, a: 0, b: 4 },
          // 바깥 네 점을 거의 사각형처럼 연결
          { id: 4, a: 1, b: 2 },
          { id: 5, a: 2, b: 3 },
          { id: 6, a: 3, b: 4 }
        ],
        // 이 그래프는 홀수 차수 정점이 2개라 한붓그리기 가능
        startNode: 0
      },
      {
        id: 3,
        title: "Stage 3 - 육각형 미로",
        description: "육각형 모양의 섬들과 여러 다리로 이루어진 복잡한 그래프입니다.",
        nodes: [
          { id: 0, x: 300, y: 80 },
          { id: 1, x: 440, y: 140 },
          { id: 2, x: 440, y: 260 },
          { id: 3, x: 300, y: 320 },
          { id: 4, x: 160, y: 260 },
          { id: 5, x: 160, y: 140 }
        ],
        edges: [
          // 육각형 링
          { id: 0, a: 0, b: 1 },
          { id: 1, a: 1, b: 2 },
          { id: 2, a: 2, b: 3 },
          { id: 3, a: 3, b: 4 },
          { id: 4, a: 4, b: 5 },
          { id: 5, a: 5, b: 0 },
          // 내부 연결(조금 더 복잡하게)
          { id: 6, a: 0, b: 3 },
          { id: 7, a: 2, b: 5 },
          { id: 8, a: 0, b: 2 }
        ],
        // 설계상 한붓그리기 가능(홀수 차수 정점 2개)
        startNode: 0
      },
      {
        id: 4,
        title: "Stage 4 - 교차 다리",
        description: "서로 교차하는 다리들이 많은 까다로운 그래프입니다. 모든 다리를 한 번씩만 지나 보세요.",
        nodes: [
          { id: 0, x: 140, y: 120 },
          { id: 1, x: 460, y: 120 },
          { id: 2, x: 460, y: 280 },
          { id: 3, x: 140, y: 280 }
        ],
        edges: [
          // 사각형 기본
          { id: 0, a: 0, b: 1 },
          { id: 1, a: 1, b: 2 },
          { id: 2, a: 2, b: 3 },
          { id: 3, a: 3, b: 0 },
          // 대각선 여러 개
          { id: 4, a: 0, b: 2 },
          { id: 5, a: 0, b: 2 },
          { id: 6, a: 1, b: 3 },
          { id: 7, a: 1, b: 3 },
          // 추가 다리 하나로 홀수 정점 2개 만들기
          { id: 8, a: 0, b: 1 }
        ],
        startNode: 0
      },
      {
        id: 5,
        title: "Stage 5 - 쾨니히스베르크의 다리",
        description:
          "역사적으로 유명한 '쾨니히스베르크의 다리'를 단순화한 그래프입니다. 한붓그리기가 가능한지 직접 해보세요.",
        nodes: [
          // 4개의 땅: 왼쪽 위, 오른쪽 위, 중앙 섬, 아래 땅 느낌
          { id: 0, x: 300, y: 200 }, // 중앙 섬
          { id: 1, x: 130, y: 110 }, // 왼쪽 위 땅
          { id: 2, x: 470, y: 110 }, // 오른쪽 위 땅
          { id: 3, x: 300, y: 320 }  // 아래 땅
        ],
        edges: [
          // 쾨니히스베르크 그래프 구조 동일 (7개의 다리)
          { id: 0, a: 0, b: 1 },
          { id: 1, a: 0, b: 1 },
          { id: 2, a: 0, b: 2 },
          { id: 3, a: 0, b: 2 },
          { id: 4, a: 0, b: 3 },
          { id: 5, a: 1, b: 3 },
          { id: 6, a: 2, b: 3 }
        ],
        startNode: 0
      }
    ];

    // ===== 공통 상태 =====
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const infoDiv = document.getElementById("info");
    const prevBtn = document.getElementById("prev");
    const nextBtn = document.getElementById("next");
    const resetBtn = document.getElementById("reset");

    const overlay = document.getElementById("overlay");
    const giveupCancelBtn = document.getElementById("giveup-cancel");
    const giveupConfirmBtn = document.getElementById("giveup-confirm");

    const resultOverlay = document.getElementById("result-overlay");
    const resultCloseBtn = document.getElementById("result-close");

    let currentLevelIndex = 0;
    let usedEdges = {}; // edgeId -> true/false
    let currentNodeId = null;
    let startNodeId = null;
    let levelCleared = false;

    // 스테이지 5 리셋 누른 횟수
    let stage5ResetCount = 0;

    // ===== 현재 레벨 =====
    function getCurrentLevel() {
      return levels[currentLevelIndex];
    }

    // ===== 평행 다리 offsetIndex 세팅 =====
    function prepareParallelOffsets(level) {
      const map = {};
      level.edges.forEach(e => {
        const key =
          e.a < e.b ? `${e.a}-${e.b}` : `${e.b}-${e.a}`;
        if (!map[key]) map[key] = [];
        map[key].push(e);
      });

      Object.values(map).forEach(edgesArr => {
        const n = edgesArr.length;
        if (n === 1) {
          edgesArr[0].offsetIndex = 0;
        } else {
          for (let i = 0; i < n; i++) {
            edgesArr[i].offsetIndex = i - (n - 1) / 2;
          }
        }
      });
    }

    // ===== 레벨 초기화 =====
    function initLevel(index) {
      currentLevelIndex = index;
      const level = getCurrentLevel();

      usedEdges = {};
      level.edges.forEach(e => {
        usedEdges[e.id] = false;
      });

      startNodeId = level.startNode;
      currentNodeId = startNodeId;
      levelCleared = false;

      // 스테이지 5 리셋 카운트 초기화
      if (level.id === 5) {
        stage5ResetCount = 0;
      }

      prepareParallelOffsets(level);

      draw();
      updateInfo();

      // 다음 스테이지 버튼 표시 조건 (1~4까지만, 클리어 후에만)
      if (level.id <= 4) {
        nextBtn.style.display = levelCleared ? "inline-block" : "none";
      } else {
        nextBtn.style.display = "none";
      }
    }

    // ===== 그리기 =====
    function draw() {
      const level = getCurrentLevel();
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // 스테이지 5는 강 느낌 배경
      if (level.id === 5) {
        ctx.fillStyle = "#b0d8ff";
        ctx.fillRect(0, 140, 600, 80);
        ctx.fillRect(0, 220, 600, 80);
      }

      // 다리(간선)
      level.edges.forEach(e => {
        const nodeA = level.nodes.find(n => n.id === e.a);
        const nodeB = level.nodes.find(n => n.id === e.b);

        const ax = nodeA.x;
        const ay = nodeA.y;
        const bx = nodeB.x;
        const by = nodeB.y;

        const dx = bx - ax;
        const dy = by - ay;
        const len = Math.sqrt(dx * dx + dy * dy) || 1;
        const nx = -dy / len;
        const ny = dx / len;

        const offsetAmount = 8;
        const offsetIndex = e.offsetIndex || 0;
        const ox = nx * offsetAmount * offsetIndex;
        const oy = ny * offsetAmount * offsetIndex;

        ctx.beginPath();
        ctx.moveTo(ax + ox, ay + oy);
        ctx.lineTo(bx + ox, by + oy);
        ctx.strokeStyle = usedEdges[e.id] ? "#999999" : "#004488";
        ctx.lineWidth = 5;
        ctx.stroke();
      });

      // 섬(노드)
      level.nodes.forEach(n => {
        const isCurrent = n.id === currentNodeId;
        ctx.beginPath();
        ctx.arc(n.x, n.y, 18, 0, Math.PI * 2);
        ctx.fillStyle = isCurrent ? "#ffcc00" : "#ffffff"; // 현재 위치 노랑
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = "#333333";
        ctx.stroke();

        ctx.fillStyle = "#000000";
        ctx.font = "14px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(n.id, n.x, n.y);
      });
    }

    // ===== 정보 UI =====
    function updateInfo(message) {
      const level = getCurrentLevel();
      const totalEdges = level.edges.length;
      const usedCount = Object.values(usedEdges).filter(v => v).length;

      let html = `
        <div><strong>${level.title}</strong></div>
        <div style="margin-top:4px;">${level.description}</div>
        <div style="margin-top:4px;">현재 스테이지: ${level.id} / ${levels.length}</div>
        <div>사용한 다리: ${usedCount} / ${totalEdges}</div>
        <div>현재 위치한 섬 ID: ${currentNodeId}</div>
        <div style="margin-top:4px; font-size: 13px; color:#555;">
          규칙: 모든 다리를 <strong>딱 한 번씩만</strong> 지나면 클리어입니다. 출발지로 돌아올 필요는 없어요.
        </div>
      `;

      if (levelCleared && level.id <= 4) {
        html += `<div style="margin-top:6px; color:#006600;"><strong>✔ 클리어했습니다! '다음 스테이지' 버튼이 활성화되었습니다.</strong></div>`;
      }

      if (message) {
        html += `<div style="margin-top:6px; color:#c00;"><strong>${message}</strong></div>`;
      }

      infoDiv.innerHTML = html;
    }

    // ===== 승리 조건 체크 (한붓그리기: 모든 다리 사용) =====
    function checkWin() {
      const level = getCurrentLevel();
      const totalEdges = level.edges.length;
      const usedCount = Object.values(usedEdges).filter(v => v).length;

      if (usedCount === totalEdges) {
        levelCleared = true;
        updateInfo("축하합니다! 모든 다리를 한 번씩만 지나갔습니다! ✅");
        // 1~4 스테이지일 때만 다음 스테이지 버튼 등장
        if (level.id <= 4) {
          nextBtn.style.display = "inline-block";
        }
        return true;
      }
      return false;
    }

    // ===== 노드 클릭 처리 =====
    function onCanvasClick(event) {
      const level = getCurrentLevel();
      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;

      const clickedNode = level.nodes.find(n => {
        const dx = x - n.x;
        const dy = y - n.y;
        return Math.sqrt(dx * dx + dy * dy) <= 20;
      });

      if (!clickedNode) {
        return;
      }

      if (clickedNode.id === currentNodeId) {
        updateInfo("이미 그 섬에 서 있습니다. 다른 섬을 눌러 보세요.");
        return;
      }

      const candidateEdges = level.edges.filter(e => {
        const connected =
          (e.a === currentNodeId && e.b === clickedNode.id) ||
          (e.b === currentNodeId && e.a === clickedNode.id);
        return connected && !usedEdges[e.id];
      });

      if (candidateEdges.length === 0) {
        updateInfo("이 두 섬 사이에 더 이상 사용할 수 있는 다리가 없습니다.");
        return;
      }

      const edgeToUse = candidateEdges[0];
      usedEdges[edgeToUse.id] = true;
      currentNodeId = clickedNode.id;

      draw();
      if (!checkWin()) {
        updateInfo();
      }
    }

    // ===== 버튼 이벤트 =====
    prevBtn.addEventListener("click", () => {
      let nextIndex = currentLevelIndex - 1;
      if (nextIndex < 0) nextIndex = levels.length - 1;
      initLevel(nextIndex);
    });

    nextBtn.addEventListener("click", () => {
      const level = getCurrentLevel();
      if (!levelCleared || level.id >= 5) {
        return;
      }
      let nextIndex = currentLevelIndex + 1;
      if (nextIndex >= levels.length) nextIndex = 0;
      initLevel(nextIndex);
    });

    resetBtn.addEventListener("click", () => {
      const level = getCurrentLevel();

      if (level.id === 5) {
        stage5ResetCount++;
        if (stage5ResetCount >= 5) {
          // 포기 오버레이 띄우기
          overlay.style.display = "flex";
        }
      }

      initLevel(currentLevelIndex);
    });

    canvas.addEventListener("click", onCanvasClick);

    // ===== 포기 오버레이 버튼 =====
    giveupCancelBtn.addEventListener("click", () => {
      overlay.style.display = "none";
    });

    giveupConfirmBtn.addEventListener("click", () => {
      overlay.style.display = "none";
      // 결과/해설 오버레이 띄우기
      resultOverlay.style.display = "flex";
    });

    // ===== 결과/해설 오버레이 버튼 =====
    resultCloseBtn.addEventListener("click", () => {
      resultOverlay.style.display = "none";
      // 처음 스테이지로 이동
      initLevel(0);
    });

    // 시작
    initLevel(0);
  </script>
</body>
</html>
